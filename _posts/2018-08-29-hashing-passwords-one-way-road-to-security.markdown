---
layout: post
title: "パスワードをハッシュする：セキュリティへの一方通行"
metatitle: "パスワードをハッシュする：セキュリティへの一方通行"
description: "堅牢なパスワードの格納戦略はどんな組織の評判をも危険にさらしてしまうデータ侵害を軽減するのに重大です。ハッシュはパスワードの格納を安全にする基盤です。"
metadescription: "堅牢なパスワードの格納戦略はどんな組織の評判をも危険にさらしてしまうデータ侵害を軽減するのに重大です。ハッシュはパスワードの格納を安全にする基盤です。"
date: 2018-08-30 08:30
auth0_aside: true
category: Technical Guide, Security
design:
  image: https://cdn.auth0.com/blog/hashing-one-way-road-to-security/hashing.png
  bg_color: "#4B673E"
author:
  name: Dan Arias
  url: http://twitter.com/getDanArias
  mail: dan.arias@auth0.com
  avatar: https://pbs.twimg.com/profile_images/1002301567490449408/1-tPrAG__400x400.jpg
tags:
  - hashing
  - salting
  - password-storage
  - security
  - hash
  - password
  - salt
  - digest
related:
  - 2018-05-03-adding-salt-to-hashing-a-better-way-to-store-passwords
  - 2017-02-24-sha-1-collision-attack
  - 2018-05-31-hashing-in-action-understanding-bcrypt
---

gist の認証はユーザー名やパスワードなどの資格情報セットをユーザーに提供し、アプリケーションにアクセスしたいときはいつでも正しい資格情報を提供することを検証することです。よって、将来、比較するときのためにこれら資格情報をデータベースに格納する方法が必要です。しかし、認証のためにパスワードをサーバーに格納することは難しい作業です。パスワードを安全に、そしてより簡単に格納するメカニズムのひとつ、ハッシュを見てみましょう。

# パスワードの格納は危険性と複雑性を伴う

パスワードを格納する簡単なアプローチはユーザー名とパスワードをマップするデータベース テーブルを作ることです。ユーザーがログインすると、サーバーはユーザー名とパスワードを含むペイロードで認証の要求を受けます。そのユーザー名をテーブルで検索し、格納されたパスワードで提供されたパスワードと比較します。それが一致すると、ユーザーはアプリケーションへのアクセスを得ます。

安全の強度とこのモデルの復元はパスワードが _どのように_ 格納されているかによって決まります。最も基本的ですが、最も安全でないパスワードの格納形式は **\*クリア\*\*\*\*** **\*\***テキスト\*\*\* です。

[_Denim Group **の** Dan Cornell \_\_氏_](https://denimgroup.com/resources/blog/2007/10/cleartext-vs-pl/) の説明によると、 **\*クリア\*\*\*\*** **\*\***テキスト*** は例えば非暗号化など、「*クリアに* 送信または格納された読み取り可能データ」を言及します。***プレーンテキスト**_ または _**テキスト形**\*\***式\*\*\* という用語もご覧になられているかもしれません。その違いは何でしょうか？Cornell 氏によると、プレーンテキストは暗号化アルゴリズムへの入力としての役割を果たすデータを言及しますが、テキスト形式はプレーンテキストファイルのコンテンツまたは `.txt` など未フォーマットのテキストを言及します。これからの作業において、これらの用語の区別して知っておくことは重要です。

パスワードをクリアテキストに格納することは、デジタルペーパーに書き込むことと同等です。攻撃者がデータベースに押し入り、パスワード テーブルを盗むとき、この攻撃者は各ユーザーアカウントにもアクセスできます。この問題は、多くのユーザーが１つのパスワードを再利用したり、１つのパスワードのバリエーションを使っているという事実からさらに複雑さを増し、攻撃者は危害を受けたものとは違う別のサービスにアクセスできる可能性があります。まったくのセキュリティの悪夢です！

攻撃は組織内から発することもあります。データベースへのアクセスがある非承認のソフトウェアエンジニアはそのアクセス権力を不正使用して、クリアテキストの資格情報を取得し、どんなアカウントにもアクセスできます。

パスワードを格納するより安全な方法は元のパスワードに戻すことができないデータにそれを変えることです。このメカニズムは **_ハッシュ_** として知られます。ハッシュの背後にある理論、その利益、その制限を見ていきましょう。

{% include jp-tweet_quote.html quote_text="私たちは内部や外部の両方からの不正アクセスからユーザーのアカウントを守らなければなりません。パスワードをクリア テキストで格納することは絶対にオプションにしないでください。ハッシュとソルトはパスワード管理戦略の一環として必ず取り入れるべきです。" %}

## ハッシュとは何か？

辞書の定義によると、[_ハッシュ_](https://en.wiktionary.org/wiki/hash) は「雑然とした煩雑」に見えるように「何かを小片に切ること」です。この定義は、ハッシュがコンピューティングで表すことに密接に当てはまります。

暗号において、[_ハッシュ関数_](https://en.wikipedia.org/wiki/Cryptographic_hash_function) は数学的なアルゴリズムで、あらゆるサイズのデータを固定サイズの [_ビット列_](http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Bit-Strings.html) にマップします。この関数入力を **_メッセージ_** または単に入力として言及できます。固定サイズ文字列の関数出力は **_ハッシュ_** または **\*メッセージ\*\*\*\*** **\*\***ダイジェスト\*\*\* として知られます。_OWASP_ で述べられているように、暗号で使用されているハッシュ関数は次のキー プロパティです。

- ハッシュを計算するのは簡単で実用的ですが、「ハッシュ値だけが知られている場合、元の入力を再生成するのは困難であったり、不可能です。」
- 特定の目的の出力に一致する初期入力を作るのは難しいです。

よって、暗号化とは対照的に、ハッシュは一方向のメカニズムです。ハッシュしたデータは実際、ハッシュ化されないようにはできません。

<p style="text-align: center;">
  <img src="https://cdn.auth0.com/blog/hashing-one-way-road-to-security/encryption-flow.png" alt="The encryption flow can be reversed. It's two-way">
</p>

<p style="text-align: center;">
  <img src="https://cdn.auth0.com/blog/hashing-one-way-road-to-security/hash-flow.png" alt="The hashing flow cannot be reversed. It's one-way.">
</p>

最もよく使われるハッシュアルゴリズムは [_MD5_](https://en.wikipedia.org/wiki/MD5)、および広く使われる SHA-256 アルゴリズムを含む SHA-1 および SHA-2 ファミリなど [_セキュア\_\_ **ハッシュ** **アルゴリズム** (SHA)_](https://en.wikipedia.org/wiki/Secure_Hash_Algorithms) などメッセージ ダイジェスト（MDx）アルゴリズムを含みます。後ほど、これらアルゴリズムの長所、その一部が使用されなくなった理由、セキュリティ脆弱性のために抜けてしまった理由などについて学んでいきます。

ビットコインでは、[_整合性およびブロックチェーン_](https://en.bitcoin.it/wiki/How_bitcoin_works) は基になる暗号学的ハッシュ関数として [_SHA-256 \_\_アルゴリズム_](https://en.wikipedia.org/wiki/SHA-2) を使用します。SHA-256 を使ってハッシュの例を見てみましょう。

入力：`python1990K0OL`

ハッシュ (SHA-256)：`3c9c93e0f8eb2161e5787f7cd3e4b67f8d98fbd80b7d237cc757583b06daa3e3`

入力：`python`

ハッシュ (SHA-256)：`98eadd540e6c0579a1bcbe375c8d1ae2863beacdfb9af803e5f4d6dd1f8926c2`

{% include jp-tweet_quote.html quote_text="ブロックチェーンや、ビットコインなどの暗号通貨を理解することで、暗号学的ハッシュ関数がどのように機能するをより簡単に理解できます。" %}

SHA-256 を使ってランダムサイズの入力を固定サイズのビット文字列に変えました。`python1990K0OL` と `python` の間の長さの違いにもかかわらず、各入力は同じ長さのハッシュを生成していることを確認しておきましょう。_16 \_\_進数の文字列表示_ を使って、各ハッシュには 64 個の数字があり、それらは 256 ビットの文字列を表し、各 16 進数は 4 ビットを表します。

暗号の他に、ハッシュ関数は広く使用されますが、そのプロパティや要件は異なり、セキュリティを提供しません。例えば、[_巡回冗長検査\_\_ \_\_(CRC)_](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) はエラーを検知するためにネットワーク アプリケーションで使用されるハッシュ関数ですが、原像計算困難性ではないので、デジタル署名などのセキュリティ アプリケーションには不適切です。

本書全体で、ハッシュ関数を暗号の使用に適したものにする必要なプロパティについて調べていきます。まず、入力がどのようにして暗号学的ハッシュ関数をハッシュに計算するかが分かったとしても、そのハッシュを入力に戻すことは実質的でないことを知っておいてください。それはなぜでしょうか？

## 暗号学的ハッシュ関数は実質的に、元に戻せない

ハッシュ関数は算術演算を使って、一方向関数としてなし、_モジュロ演算_ のようなものを元に戻すのは非常に難しく、かつ厄介です。

モジュロ演算は除算の余りを与えます。例えば、`5 mod 3` は `2` なので整数除数を使って `5 / 3` の余りは `2` になります。この演算は決定論的で、同じ入力が常に同じ出力を生成するとすれば、数学的には、`5 / 3` は常に `2` になります。ただし、モジュロ演算の重要な特性はその結果が与えられた元の [_オペランド_](https://en.wikipedia.org/wiki/Operand) を見つけられないことです。 この理由から、ハッシュ関数は元に戻すことができません。

モジュロ演算の結果が `2` であることは `x` を `y` で除算した余りが `2`であることが分かりますが、`x` や `y` についてはまったく分かりません。`x mod y` が `2` を返す `x` や `y` に置き換えられる数値は無数にあります。

`7 mod 5 = 2`

`9 mod 7 = 2`

`2 mod 3 = 2`

`10 mod 8 = 2`

`...`

暗号学的ハッシュ関数を使うとき、**_ハッシュ_** を見るだけでは **_プレイメージ_** は見つかりません。プレイメージは、入力としてハッシュ関数に使用されたときにある種の特定ハッシュを生成する値をそのように呼びます。暗号学的ハッシュ関数は [_原像攻撃_](https://en.wikipedia.org/wiki/Preimage_attack) に抵抗を示すように設計されているので、**_原像計算困難性_** でなければなりません。ですから、攻撃者がハッシュについて知っていれば、その与えられた出力にハッシュする入力を見つけることはコンピューター的に実行不可能です。このプロパティは [_ビットコインやブロックチェーンの基盤_](https://auth0.com/blog/an-introduction-to-ethereum-and-smart-contracts/) のひとつをハッシュさせるものです。

ハッシュ関数がどのように機能するかについては、この [_ウィキペディアの記事_](https://en.wikipedia.org/wiki/SHA-2) がセキュア ハッシュ アルゴリズム 2（SHA-2）の機能について詳細に説明しています。

## 小さな変更が大きな影響を与える

セキュアハッシュ関数のもうひとつの長所はその出力は予測が簡単でないということです。`dontpwnme4` のハッシュは `dontpwnme5` のハッシュとは非常に異なります。文字列の最後の文字のみを変えたとしても、両方の文字列はアルファベット順にソートしたリストに隣接されています。

入力：`dontpwnme4`

ハッシュ (SHA-256)：`665ec59d7fb01f6070622780e744040239f0aaa993eae1d088bc4f0137d270ef`

入力：`dontpwnme5`

ハッシュ (SHA-256)：`7ae89eb10a765ec2459bee59ed1d3ed97dbb9f31ec5c7bd13d19380bc39f5288`

このプロパティは [_アバランシェ効果_](https://en.wikipedia.org/wiki/Avalanche_effect) として知られ、入力が少し変わっても望ましい効果があり、その出力は大幅に変更されます。

必然的に、`dontpwnme6` のハッシュが何の２つの前のハッシュを基にしているかを決定する実行可能な方法はありません。

## より安全性の高いパスワード格納のために暗号学的ハッシュを使用する

ハッシュを元に戻すことができない数学的特性は驚異的なメカニズムを作り、保存されているパスワードや移動中のパスワードを隠します。ハッシュ関数がパスワード格納に適切なもうひとつの重要な特性はこれらは決定論的関数だということです。

**_決定論的_** 関数は同じ入力が与えられれば常に同じ出力を生成するという関数です。これは、定められたパスワードは常に同じハッシュを生成することが保証される必要があるので、認証に極めて重要です。そうでなければ、この手法でユーザー資格情報を一環して確認することは不可能です。

ハッシュをパスワード格納フローに統合するには、ユーザーが作成されたときに、パスワードをクリアテキストに格納する代わりに、そのパスワードをハッシュしてそのユーザー名を格納し、データベース テーブルに対をハッシュします。ユーザーがログインするとき、送信されたパスワードをハッシュし、それを提供されたユーザー名に接続されたハッシュと比較します。ハッシュされたパスワードと格納されたハッシュが一致すると、有効なログインができます。クリア テキストのパスワードをそのプロセスに絶対に格納しないことに注意することが重要です。ハッシュしてそれを削除します。

送信するパスワードは暗号化されるべきであるのに対して、パスワード ハッシュの格納には暗号化される必要がありません。適切に実装されたとき、パスワード ハッシュは暗号学的に安全です。この実装には、ハッシュ関数の制限を解決する長いソルト値を使用します。

## ハッシュ関数の制限

ハッシュはかなり信頼性が高いようです。しかし、多数あるシナリオのひとつで、もしある攻撃者がサーバーに参入して、パスワードハッシュを盗んだとしても、攻撃者が見えるのはハッシュ関数のアーキテクチャのため、元に戻すことができないランダム データだけです。攻撃者は認証に使用するハッシュを作成するために、ハッシュ関数への入力を提供する必要があります。これはサーバーに赤いフラグを挙げなくてもオフラインでできます。

攻撃者は [_現代のフィッシングやスプーフィングの技法_](https://auth0.com/blog/the-new-trend-of-artisanal-spam/) を通してユーザーからクリアテキスト パスワードを盗むか、または攻撃者は一致するハッシュが見つかるまでハッシュ関数にランダム パスワードを入力する **\*ブルート\*\*\*\*** **\*\***フォース攻撃\*\*\* のどちらかを実装します。

ブルート フォース攻撃のほとんどは非効率です。攻撃者に他のオプションがありますか？

ハッシュ関数は決定論的関数（同じ関数が常に同じハッシュを入力する）ので、数名のユーザーが同じパスワードを使用したら、そのハッシュは同一になります。たくさんの人たちが、そのハッシュが一般によく使われるパスワードを表すサインになる同じハッシュにマップしたら、攻撃者はブルート フォース攻撃で押し入るために使用するパスワード数を大幅に軽減できることになります。

さらに、**\*レインボーテーブル\*\*\*\*** **\*\***アタック**_ を通して、攻撃者は事前計算済みハッシュの大規模なデータベースを使用して、盗まれたパスワード ハッシュの入力を探します。格納された瞬間に一意のランダムデータを各入力に追加する手順でハッシュをブーストしてレインボーテーブル アタックを軽減することができます。この方法は [_**ソルトをハッシュに追加する**_](https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/) 方法として知られ、_**ソルト付きパスワードのハッシュ\*\*\* を生成します。

ハッシュにはソルトが付いているので、パスワードだけの値を基にしません。入力はパスワードとソルトで成ります。レインボーテーブルは予測パスワードのセットで構成されています。これらパスワードのハッシュにソルトが含まれなければ、レインボーテーブルは無駄になります。攻撃者がこのソルトを手にすると、レインボーテーブルは再計算されなければなりません。この再計算は長い時間をかけることが理想的ですので、この攻撃ベクトルをさらに軽減します。

_「ハッシュを「破る」取り組みが、犯人たちがそうすることで得る値を超えるようにすることがその秘訣です。これは「ハッキングできないようにする」ことではなく、そのようにする努力に値しないように困難にすることです。」_- [_Troy Hunt_](https://twitter.com/troyhunt)

## 高速の必要はない

[_Jeff Atwood \_\_氏_](https://blog.codinghorror.com/speed-hashing/) によると、「セキュリティに使用するハッシュは低速にする必要がある」と言います。パスワード ハッシュに使用される暗号学的ハッシュ関数は、特に急速に発展している現代のソフトウェアの力で素早く計算されたアルゴリズム、ブルート フォース攻撃をさらに実行可能にさせる可能性があるので、計算する速度を低速にする必要があります。これは、多数の内部反復を使ったり計算メモリを集約したりしてハッシュ計算を遅くして達成します。

低速な暗号学的ハッシュ関数はそのプロセスを妨げますが、ハッシュ計算の速度は良かれと思って実行するユーザーや悪意のあるユーザーの両方に影響するので、そのプロセスを停止させません。ハッシュ関数の速度と使用可能性のバランスを良くすることが重要です。良かれと思って実行するユーザーが１回の有効なログインをするとき、パフォーマンスへの影響はほとんど気づきません。

## 衝突攻撃はハッシュ関数を廃止する

ハッシュ関数はどんなサイズの入力も取り込むことができますが、固定サイズの文字列のハッシュを生成するので、可能な入力セットは無限ですが可能な出力セットは限定されます。これは、同じハッシュにマップする複数の入力を可能にします。よって、ハッシュを反転できても、その結果が選択された入力になるということを確実に知ることはできません。これは衝突と呼ばれ、望ましい効果ではありません。

暗号学的衝突は２つの固有の入力が同じハッシュを生成するときに起きます。その結果として、[**_衝突攻撃_**](https://en.wikipedia.org/wiki/Collision_attack) は同じハッシュを生成した２つのプレイメージを探そうとします。攻撃者は不正のデータまたは悪意のあるデータを使って有効なハッシュが偽造されたハッシュ値に依存するシステムをだまそうとするこの衝突を使用するかもしれません。従って、暗号学的ハッシュ関数は攻撃者がこのような固有の値を見つけられないようにして、衝突攻撃を困難にしなければなりません。

{% include jp-tweet_quote.html quote_text="入力は無限の長さでハッシュが固定の長さなので、衝突が可能になります。衝突のリスクは統計的に非常に低いですが、衝突は最もよく使用されているハッシュ関数で見つかっています。" %}

シンプルなハッシュアルゴリズムの場合、シンプルな Google 検索でハッシュをクリアテキスト入力に戻すツールを見つけることができます。[_MD5_](https://security.googleblog.com/2014/09/gradually-sunsetting-sha-1.html) アルゴリズムと [_SHA1_](https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html) アルゴリズムは使用が安全でないと見なされ、暗号衝突が発生するため Google では非推奨されています。

Google では SHA-256 や SHA-3 のような強力なハッシュアルゴリズムの使用を推奨しています。実践で最も良く使用される他のオプションは `bcrypt`、`scrypt`、`PBKDF2`、など [_この暗号アルゴリズムのリストで見\_\_つける_](https://en.wikipedia.org/wiki/List_of_algorithms) ことができます。しかしながら、これまで学んできたように、ハッシュだけでは十分ではなく、ソルトと合わせて使用するべきです。_ハッシュにソルトを追加してパスワードを格納するのはより良い方法_ についての詳細をご覧ください。

## まとめ

本書で学んだ事柄をまとめてみましょう。

- ハッシュの核となる目的はデータの機密性ではなく、整合性を評価する指紋データを作ることです。機密性は暗号化を通して得ることができます。
- ハッシュ関数は任意の入力を取り、それらを固定長の出力に変えます。
- 暗号学的ハッシュ関数として評価されるには、ハッシュ関数はプレイメージが困難で衝突耐性でなければなりません。
- レインボーテーブルのため、ハッシュだけでパスワードを大量の危険から守ることは十分ではありません。この攻撃ベクトルを軽減するには、ハッシュは暗号用ソルトと合わせて使用しなければなりません。
- すべての暗号アルゴリズムが現代産業に適しているというものではありません。本書を書いている時点では、MD5 と SHA-1 が衝突のため攻撃を受けやすいと Google がレポートしています。SHA-2 ファミリがより良い選択肢と言えるようです。

## Auth0 でパスワード管理を簡単にする

[_Auth0_](https://auth0.com/) を介してハッシュ、ソルト、パスワード管理のオーバヘッドを最小限にすることができます。最も複雑な ID 問題を拡張可能で、統合が簡単なプラットフォームで解決し、毎月何億回というログインを確実にします。

Auth0 は重要な ID データが悪の手に渡らないようにします。パスワードは絶対にクリアテキストに格納しないでください。パスワードは必ずハッシュして [_bcrypt_](https://en.wikipedia.org/wiki/Bcrypt)でソルトします。 さらに、保存データや移動中のデータは 128 ビット以上の AES 暗号の TLS を使って必ず暗号化します。最新のセキュリティを当製品に取り入れ、ビジネスやユーザーを保護します。

インターネットをより安全にするには、今すぐ [_無料** Auth0 **アカウントにご登録ください_](https://auth0.com/signup)。
